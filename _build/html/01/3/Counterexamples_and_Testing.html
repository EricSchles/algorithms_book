
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Counter Examples and Testing &#8212; The Analysis Of Algorithms</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.e8f53015daec13862f6db5e763c41738.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Types" href="../4/Types_and_Induction.html" />
    <link rel="prev" title="Introduction To Proofs" href="../2/Introduction_To_Proofs.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      
      <h1 class="site-logo" id="site-title">The Analysis Of Algorithms</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../plan.html">
   Analysis Of Algorithms
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="../chapter_one_intro.html">
   Algorithms Foundations
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="../1/Introduction_to_Python.html">
     Introduction To Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../2/Introduction_To_Proofs.html">
     Introduction To Proofs
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Counter Examples and Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../4/Types_and_Induction.html">
     Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../5/First_Algorithms.html">
     First Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../6/statistical_analysis_of_algorithms.html">
     Statistical Analysis of Algorithms
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/01/3/Counterexamples_and_Testing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/01/3/Counterexamples_and_Testing.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#proof-by-counter-example">
   Proof By Counter Example
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#testing-in-python">
   Testing In Python
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#docker-terraform">
   Docker &amp;&amp; Terraform
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#installation">
     Installation
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#getting-started">
     Getting Started
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#terraform">
     Terraform
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sequential-testing">
   Sequential Testing
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example">
     Example
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction-to-randomness">
   Introduction To Randomness
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#probability-basics">
     Probability basics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#distributions">
     Distributions
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#random-testing">
   Random Testing
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="counter-examples-and-testing">
<h1>Counter Examples and Testing<a class="headerlink" href="#counter-examples-and-testing" title="Permalink to this headline">¶</a></h1>
<p>In the last section we learned how to prove or verify things.  In this section we’ll learn about one of the technique for proving mathematical statements: proof by counter example.  This powerful technique honestly doesn’t get enough love or attention in most mathematical theory books.  This is likely because it’s not terribly interesting from a purely theoretical perspective.  To carry out a proof by counter example, you simply need to find <em>some</em> example that your statement fails on.  This is because mathematical statements are <em>either</em> true or false, but never both.  We saw this in the last section with respect to logic.</p>
<p>What is likely ‘uninteresting’ about proof by counterexample comes from a question - how do you intelligently guess a bad example?  If we <em>could</em> do that, then we’d probably know ahead of time that our theorem or lemma was correct or incorrect ahead of time, right?</p>
<p>Well, it turns out, this is one of the great powers of computational systems.  We don’t <em>need</em> to guess intelligently when computers are involved, because we can guess thousands or millions or even <em>billions</em> of times without doing very much work.</p>
<p>In this chapter we will introduce a number of ideas which will aid us in finding counterexamples for conjectures regarding mathematical statements.  We will use Python in order to do this and a mental ‘testing’ framework.  Additionally, to ensure that our set up is not the reason that our tests pass, we will be running all of our tests in a tool called Docker.  In general, Docker will be useful throughout the book because of the content we will cover in the next section, however traditionally, it is taught along side testing, so we introduce it here.</p>
<p>Finally, we will need an understanding of randomness in order to intelligently search for counter examples, so we’ll see some rudiments of probability and statistics in this chapter as well.</p>
<div class="section" id="proof-by-counter-example">
<h2>Proof By Counter Example<a class="headerlink" href="#proof-by-counter-example" title="Permalink to this headline">¶</a></h2>
<p>Before we see how to do this in Python, let’s look at some example proofs that make use of counterexamples.  As we stated above, proof by counterexample occurs when we come up with an example that disproves a conjecture.  Let’s look at some example:</p>
<p>Conjecture:</p>
<p>The function <span class="math notranslate nohighlight">\(f(x) = x^{4}\)</span> is bijective such that <span class="math notranslate nohighlight">\(f: \mathbb{R} \rightarrow \mathbb{R}\)</span>.</p>
<p>Disprove:</p>
<p>Note: Here we say disprove, because we are <strong>not</strong> trying to prove the conjecture, but refute it.</p>
<p>Assume <span class="math notranslate nohighlight">\(f(x) = x^{4}\)</span> is a bijective function.  This implies that <span class="math notranslate nohighlight">\(\forall\)</span> x in the domain such that x <span class="math notranslate nohighlight">\(\in \mathbb{R}\)</span> there is <em>one and only one</em> y in the codomain, such that y <span class="math notranslate nohighlight">\(\in \mathbb{R}\)</span>.</p>
<p>Counter example:</p>
<p>both (1, 1), (-1, 1) <span class="math notranslate nohighlight">\(\in f\)</span>:</p>
<p><span class="math notranslate nohighlight">\(1^{4}\)</span> = 1</p>
<p><span class="math notranslate nohighlight">\(-1^{4}\)</span> = 1</p>
<p>Thus, <span class="math notranslate nohighlight">\(x^{4}\)</span> is <em>not</em> bijective.</p>
<p>QED.</p>
<p>The general structure of this proof by counter example was to state the condition required for the statement to be true, and then show that a specific example fails to meet that condition.</p>
<p>Conjecture:</p>
<p>Any function of the form <span class="math notranslate nohighlight">\(f(x) = x^{k}\)</span> where k is even, in otherwords, k = 2 * l for some l <span class="math notranslate nohighlight">\(\in \mathbb{Z}\)</span>.</p>
<p>To show a counter example here, we need to cover every function such that <span class="math notranslate nohighlight">\(f(x) = x^{k}\)</span> where k is even.</p>
<p>Choose a <span class="math notranslate nohighlight">\(\in \mathbb{R}\)</span> and -a <span class="math notranslate nohighlight">\(\in \mathbb{R}\)</span> as elements from the domain.   To get the corresponding elements in the codomain we simply do:</p>
<div class="math notranslate nohighlight">
\[f(a) = a^{k} = a^{2l} = (a^{l})^{2}\]</div>
<div class="math notranslate nohighlight">
\[f(-a) = -a^{k} = -a^{2l} = (-a^{l})^{2}\]</div>
<p>At this point we need a specific fact -</p>
<p>Lemma: Any x <span class="math notranslate nohighlight">\(\in \mathbb{R}\)</span> such that <span class="math notranslate nohighlight">\(x = y^{2}\)</span> will be &gt;= 0.</p>
<p>Proof:</p>
<p>Case 1: y &gt; 0:</p>
<p>y &gt; 0, therefore y * y &gt; 0.</p>
<p>Case 2: y &lt; 0:</p>
<p>y &lt; 0, therefore we can do (-1) * y &gt; 0.</p>
<p>((-1) * y) * ((-1) * y) &gt; 0. (since we want to know the behavior of <span class="math notranslate nohighlight">\(y^{2}\)</span>).</p>
<p>(-1) * (-1) * y * y &gt; 0. (rearranging because mutliplication is associative)</p>
<p>y * y &gt; 0. (by -1 * -1 = 1 and 1 * a = a <span class="math notranslate nohighlight">\(\forall\)</span>a)</p>
<p>QED.</p>
<p>Back to the original proof.  Now we know <span class="math notranslate nohighlight">\(x^{2}\)</span> &gt; 0.  So we know:</p>
<div class="math notranslate nohighlight">
\[ (a^{l})^{2} = (-a^{l})^{2} \]</div>
<p>Since the only difference between the left and right hand side of the equation is the <code class="docutils literal notranslate"><span class="pre">-</span></code> symbol.  Therefore,</p>
<p>(a, <span class="math notranslate nohighlight">\(a^{k}\)</span>), (-a, <span class="math notranslate nohighlight">\(a^{k}\)</span>) <span class="math notranslate nohighlight">\(\in f(x)= x^{k}\)</span>, <span class="math notranslate nohighlight">\(\forall k\)</span> such that k is even.</p>
<p>So we have found <em>infinite</em> counter examples.</p>
<p>QED.</p>
<p>Now that we understand how to prove things by counterexample, let’s move onto how Python can aid us in looking for counterexamples through automation.</p>
</div>
<div class="section" id="testing-in-python">
<h2>Testing In Python<a class="headerlink" href="#testing-in-python" title="Permalink to this headline">¶</a></h2>
<p>In the last section we looked at how to come up with counterexamples to falisfy conjectures.  Now we’ll learn how to extend that to code.  The ideas are essentially analogous, so let’s jump right into an example.</p>
<p>Suppose you have some code:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">multiplication</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">product</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="n">product</span> <span class="o">+=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">product</span>
</pre></div>
</div>
</div>
</div>
<p>How can you be sure that the function works as expected?  The answer is to try <em>cases</em>.  These are specific examples we expect to work on the code, and the hope is that these examples are representative.</p>
<p>Let’s write some tests for the above function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_one_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">30</span>
    
<span class="k">def</span> <span class="nf">test_two_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>

<span class="k">def</span> <span class="nf">test_three_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    
<span class="k">def</span> <span class="nf">test_four_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
    
<span class="k">def</span> <span class="nf">test_five_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">test_six_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
    
<span class="k">def</span> <span class="nf">test_seven_multiplication</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>

<span class="n">test_one_multiplication</span><span class="p">()</span>
<span class="n">test_two_multiplication</span><span class="p">()</span>
<span class="n">test_three_multiplication</span><span class="p">()</span>
<span class="n">test_four_multiplication</span><span class="p">()</span>
<span class="n">test_five_multiplication</span><span class="p">()</span>
<span class="n">test_six_multiplication</span><span class="p">()</span>
<span class="n">test_seven_multiplication</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">TypeError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">2</span><span class="o">-</span><span class="mi">542</span><span class="n">a049348c2</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">     </span><span class="mi">26</span> <span class="n">test_five_multiplication</span><span class="p">()</span>
<span class="g g-Whitespace">     </span><span class="mi">27</span> <span class="n">test_six_multiplication</span><span class="p">()</span>
<span class="ne">---&gt; </span><span class="mi">28</span> <span class="n">test_seven_multiplication</span><span class="p">()</span>

<span class="nn">&lt;ipython-input-2-542a049348c2&gt;</span> in <span class="ni">test_seven_multiplication</span><span class="nt">()</span>
<span class="g g-Whitespace">     </span><span class="mi">18</span> 
<span class="g g-Whitespace">     </span><span class="mi">19</span> <span class="k">def</span> <span class="nf">test_seven_multiplication</span><span class="p">():</span>
<span class="ne">---&gt; </span><span class="mi">20</span>     <span class="k">assert</span> <span class="n">multiplication</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
<span class="g g-Whitespace">     </span><span class="mi">21</span> 
<span class="g g-Whitespace">     </span><span class="mi">22</span> <span class="n">test_one_multiplication</span><span class="p">()</span>

<span class="nn">&lt;ipython-input-1-acc5898df278&gt;</span> in <span class="ni">multiplication</span><span class="nt">(x, y)</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="k">def</span> <span class="nf">multiplication</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span>     <span class="n">product</span> <span class="o">=</span> <span class="mi">0</span>
<span class="ne">----&gt; </span><span class="mi">3</span>     <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span>         <span class="n">product</span> <span class="o">+=</span> <span class="n">x</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span>     <span class="k">return</span> <span class="n">product</span>

<span class="ne">TypeError</span>: &#39;float&#39; object cannot be interpreted as an integer
</pre></div>
</div>
</div>
</div>
<p>Looks like our implementation failed on test seven!  This is because we implemented multiplication in such a way as it does not succeed if the second parameter is a float.</p>
<p>In general testing is a way of assessing correctness, the same way that we can assess correctness for a proof.  It may seem like we haven’t really done much, but testing allows us to have <em>assurance</em> that our algorithms are correct on those specific cases.  So if there is something wrong with our implementation, we can always assess it.</p>
<p>In general the syntax for tests will always be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_</span><span class="p">[</span><span class="n">number</span><span class="p">]</span><span class="n">_</span><span class="p">[</span><span class="n">function</span> <span class="n">we</span> <span class="n">are</span> <span class="n">testing</span><span class="p">](</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="o">..</span> <span class="n">paramN</span><span class="p">):</span>
    <span class="n">some</span> <span class="n">logic</span> <span class="n">to</span> <span class="nb">set</span> <span class="n">up</span> <span class="n">the</span> <span class="n">test</span> <span class="n">goes</span> <span class="n">here</span>
    <span class="k">assert</span> <span class="p">[</span><span class="n">function</span> <span class="n">we</span> <span class="n">are</span> <span class="n">testing</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="n">some</span> <span class="n">case</span> <span class="n">where</span> <span class="n">we</span> <span class="n">know</span> <span class="n">the</span> <span class="n">expected</span> <span class="n">output</span><span class="p">]</span>
</pre></div>
</div>
<p>Notice the use of <code class="docutils literal notranslate"><span class="pre">assert</span></code> here.  The way <code class="docutils literal notranslate"><span class="pre">assert</span></code> works is, it checks a boolean.</p>
<p>If the boolean is true - then nothing happens.
If the boolean is false - then an error is raised.</p>
<p>In this way we can <em>always</em> tell if the program failed.  And it will fail <em>explicitly</em>.</p>
<p>Now that we know the basics of testing, time to go over some more technology that we’ll be using throughout this book.</p>
</div>
<div class="section" id="docker-terraform">
<h2>Docker &amp;&amp; Terraform<a class="headerlink" href="#docker-terraform" title="Permalink to this headline">¶</a></h2>
<p>In general, algorithms will perform differently on different machines.  This might be because of the operating system, the version of programming language, in our case Python, or because of the hardware.  There isn’t much we can do to assess hardware related performance checks, unless you happen to have a bunch of computers lying around.  But we <em>can</em> check for differences in performance due to the operating system and the version of Python.  For this we are going to need to <em>simulate</em> the operating system and version of Python.  Mostly because installing a bunch of different operating systems and Python versions on one physical computer is a giant pain.</p>
<p>For this we will be using Docker, a powerful and relatively easy to use tool for simulating an operating system.  As for what kinds of operating systems we’ll be using - this will be only flavors of linux.  That’s because windows isn’t free, and the author feels charging someone for learning tools is unfair.</p>
<div class="section" id="installation">
<h3>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h3>
<p>In order to get docker working please follow along with this <a class="reference external" href="https://docs.docker.com/get-docker/">guide</a>.  Make</p>
<p>Now that you have docker installed, please go ahead and register for <a class="reference external" href="https://hub.docker.com/">dockerhub</a></p>
</div>
<div class="section" id="getting-started">
<h3>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h3>
<p>Now that you have docker installed, let’s talk about exactly how it works and what it is.  Docker is a “runtime” environment for “containers”.  A container is like an operating system, except very tiny and only with the specific pieces you want.  You can have a container that does <em>everything</em> a regular operating system does, but typically you only want or need certain parts of the operating system.</p>
<p>Now that we’ve talked about <em>what</em> docker is (a little), let’s talk about why you would use it.  Docker allows you to package up an environment along with an application, and ensure that the application will always run, regardless of what machine it’s on.  If you’ve ever tried to get someone else’s application running from source, then you will understand just how powerful this is.  Before containers and Docker (which are two seperate things), it was <em>very</em> hard for software engineers to package up their code into applications.  And many ‘applications’ you’d find on github and other open source systems would be <em>very</em> hard to get running.  With containers, you can just pull down the environment that the original developers used, and run the code (assuming the container was created correctly).  More or less, in developer speak, containers let you “ship your machine” along with the code.  So you don’t have to worry as much.</p>
<p>Now, why will we be using Docker?  This is getting a little ahead of things, but it’s worth it to understand the motivation.  We are learning Docker/containers because not all operating systems will run the same code the same way.  And by using this technology we can ensure that we have enough statistically diverse environments to ensure we get an accurate measure of the algorithmic performance of our code.  If this motivation went over your head, don’t worry too much.  We’ll be introducing the analysis of algorithms soon.  And hopefully then it will make much more sense.</p>
<p>Alright!  Now it’s time to try making some docker containers!  We’ll start with the “hello world” example.  This is the example that does the <em>least</em> amount possible.  So it should be the easiest for anyone to create.</p>
<p>First, create a directory called hello_world, then <code class="docutils literal notranslate"><span class="pre">cd</span></code> into that directory and then you’ll save the following code to a file, hello_world.py:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hello World!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>If you aren’t familiar with the command line, I highly recommend checking out:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://cs.lmu.edu/~ray/notes/bash/">this introduction</a></p></li>
<li><p><a class="reference external" href="https://livecodestream.dev/post/introduction-to-bash-for-beginners/">this introduction</a></p></li>
<li><p><a class="reference external" href="https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">this introduction</a></p></li>
<li><p><a class="reference external" href="https://www.educative.io/blog/bash-shell-command-cheat-sheet">this cheatsheet</a></p></li>
</ul>
<p>Next, we’ll create a file called a Dockerfile, this file store the instructions for creating our container:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FROM</span> <span class="n">python</span><span class="p">:</span><span class="mf">3.6</span><span class="o">-</span><span class="n">slim</span>

<span class="n">WORKDIR</span> <span class="o">/</span><span class="n">app</span>

<span class="n">ADD</span> <span class="o">.</span> <span class="o">/</span><span class="n">app</span>

<span class="n">RUN</span> <span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">r</span> <span class="n">requirements</span><span class="o">.</span><span class="n">txt</span>

<span class="n">EXPOSE</span> <span class="mi">80</span>

<span class="n">ENV</span> <span class="n">NAME</span> <span class="n">HelloWorld</span>

<span class="n">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;python&quot;</span><span class="p">,</span> <span class="s2">&quot;hello_world.py&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note: explain docker file code.</p>
<p>Now that you’ve got your Dockerfile and your code, you’ll create your container with:</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span> <span class="pre">-t</span> <span class="pre">hello_world:0.1</span> <span class="pre">.</span></code></p>
<p>Okay now go ahead and run your docker container with:</p>
<p><code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">-p</span> <span class="pre">80:80</span> <span class="pre">hello_world:0.1</span></code></p>
<p>And that you’ve got the basics for dockerfiles you are ready to push your container up to dockerhub.  Then you can use the container from any machine!</p>
<p>Pulling down docker containers can be kinda a pain, so to use it, we’ll make use of another technology: Terraform.</p>
<p>The reason we are introduing a second technology is, the author has created docker containers for each algorithm and pushed them to dockerhub, as well as included terraform scripts to pulldown each container.  So in order to make your life as well as the instructor’s life easier, we are going to make use of this tool.</p>
</div>
<div class="section" id="terraform">
<h3>Terraform<a class="headerlink" href="#terraform" title="Permalink to this headline">¶</a></h3>
<p>Terraform is a tool for deploying a service to some “infrastructure” this typically means the cloud, but in our case, it means to docker.  Using terraform it will be easy to download a given piece of code, run the code, get the necessary data from the code, and do the homeworks.  At first this make seem daunting, having to learn so many new technologies all in a row, but it will be to your benefit, as these tools are <em>also</em> industry standard for computer scientists.</p>
<p>Because the Terraform documentation is so good, please head to the <a class="reference external" href="https://learn.hashicorp.com/collections/terraform/docker-get-started">official docs</a> to get started with terraform</p>
<p>Now that you know how terraform works, let’s run the following script to pull down our hello_world example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#terraform script goes here</span>
</pre></div>
</div>
</div>
</div>
<p>Recall from the tutorial we need to run:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">terraform</span> <span class="pre">init</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">terraform</span> <span class="pre">fmt</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">terraform</span> <span class="pre">plan</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">terraform</span> <span class="pre">apply</span></code></p></li>
</ul>
<p>from the command line.  Once we’ve done that, the docker container should be running!</p>
<p>Now that we’ve seen how to containerize our code.  And push and pull our containers, let’s move onto some more testing paradigms.</p>
</div>
</div>
<div class="section" id="sequential-testing">
<h2>Sequential Testing<a class="headerlink" href="#sequential-testing" title="Permalink to this headline">¶</a></h2>
<p>If your algorithm is the first of it’s kind to do a specific thing, then testing specific values is the best you can hope for.  That said, many algorithms actually do <em>the same thing</em> just in different ways.  In this sense, we can think of an algorithm like a mathematical relation, except instead of one rule that gives us the mathematical rule on the relation, we can have <em>several</em> primitives build up to a rule in different ways.  This difference in how primitives are used to build towards mathematical rules is what allows algorithms to vary in performance in terms of speed.  For algorithms, it is not enough to be correct, it is also about getting to the right answer quickly.</p>
<p>Of course, correctness cannot always be guaranteed with an algorithm in absolute terms, the way it can be for a mathematical function.  This is due to the limited capacity of memory in computers - there is a finite amount of numbers a computer can accurately express, even when it comes to the integers.  This is even worse for the floating point numbers since even very small numbers, in terms of magnitude, can have many significant digits.  So, typically when we think of correctness for algorithms, we think about this in terms of some <em>large</em> set of computables, but not <em>every</em> number.</p>
<p>Given the above notion of correctness, as well as the ability to choose from a variety of “correct” algorithms, it is often advantageous to choose a given correct, however possibly inefficient algorithm and use that as a sanity check for a range of values for a new and possibly more efficient algorithm.</p>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>A very common task in algorithms is sorting numbers.  Below we’ll look at a very simple sorting routinue, that takes in a list of numbers and sorts them from lowest to highest:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arr</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s look at an example list and see the sorted list:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">listing</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

<span class="n">simple_sort</span><span class="p">(</span><span class="n">listing</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 2, 4, 5, 6, 7]
</pre></div>
</div>
</div>
</div>
<p>As you can see, the sorting algorithm sorts all the numbers, even though there are repeats.  But how can we be sure that the sorting algorithm will work on a bunch of arrays?  For this we can come up with a test, however, it will require a <em>reference implementation</em> of sorting, that we currently trust.  Fortunately Python comes with a builtin sort:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">listing</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="n">listing</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">listing</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1, 2, 2, 4, 5, 6, 7]
</pre></div>
</div>
</div>
</div>
<p>All that remains now is to devise our test with sequentially increasing and diverse inputs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_simple_sort_one</span><span class="p">():</span>
    <span class="n">listing</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">listing</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
        <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">listing</span><span class="p">[:]</span>
        <span class="n">sorted_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">simple_sort</span><span class="p">(</span><span class="n">listing</span><span class="p">)</span> <span class="o">==</span> <span class="n">sorted_list</span>
        
<span class="k">def</span> <span class="nf">test_simple_sort_two</span><span class="p">():</span>
    <span class="n">listing</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">listing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="n">sorted_list</span> <span class="o">=</span> <span class="n">listing</span><span class="p">[:]</span>
        <span class="n">sorted_list</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">simple_sort</span><span class="p">(</span><span class="n">listing</span><span class="p">)</span> <span class="o">==</span> <span class="n">sorted_list</span>

<span class="n">test_simple_sort_one</span><span class="p">()</span>
<span class="n">test_simple_sort_two</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>As you can see, we were able to easily verify <em>2000</em> cases with just a few lines of code!  The above code does take a little while because our simple sort isn’t terribly fast.  But we know it’s correct!  Now let’s look at an example that converts numbers to their binary representation.</p>
<p>In general a binary number can represent <em>any</em> integer and do so in a space efficient manner.  This means that we can <em>extend</em> the limitation of our computational resources however we certainly still have <em>a limit</em>, it’s just bigger!  Anywho, let’s look at Python’s implementation first:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">bin</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;0b10000&#39;
</pre></div>
</div>
</div>
</div>
<p>The leading 0b doesn’t have anything to do with the number, it’s just there to designate this as a binary number.  Let’s look at a second example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">bin</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;0b11&#39;
</pre></div>
</div>
</div>
</div>
<p>What should be clear from these two examples is how binary numbers appear as <em>even</em> or <em>odd</em> numbers.  Any even number will have a <code class="docutils literal notranslate"><span class="pre">0</span></code> in the position furthest to the right, while any odd number will have a <code class="docutils literal notranslate"><span class="pre">1</span></code> there.  That’s because <span class="math notranslate nohighlight">\(2^{0}=1\)</span>.  In general the formula for a binary number is:</p>
<div class="math notranslate nohighlight">
\[ membership(N) * 2^{N} + membership(N-1) * 2^{N-1} + ... + membership(1)*2^{1} + membership(0) *2^{0} \]</div>
<p>The <span class="math notranslate nohighlight">\(membership\)</span> function indicates whether or not a given power of two is used in the binary representation.  If it is, then the <span class="math notranslate nohighlight">\(membership\)</span> function returns 1, if it’s not then the <span class="math notranslate nohighlight">\(membership\)</span> function returns 0.  Then all the <span class="math notranslate nohighlight">\(membership\)</span> function values are recorded, which is what gives us the binary number.</p>
<p>So for the binary representation of the number 3, we first have to bound the number by the largest power of two, in this case it’s 4, since 4 &gt; 3.  Then we simply subtract off powers of two until we get to zero:</p>
<div class="math notranslate nohighlight">
\[0 * 2^{2} + 1 * 2^{1} + 1 * 2^{0}\]</div>
<p>Hence our binary representation is, 011.</p>
<p>Let’s write some code to capture this algorithm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">integer_to_binary</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="n">biggest_power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">biggest_power_of_two</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">):</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>
    <span class="n">binary_representation</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power_of_two</span> <span class="o">&gt;</span> <span class="n">number</span><span class="p">:</span>
            <span class="n">binary_representation</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binary_representation</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
            <span class="n">number</span> <span class="o">-=</span> <span class="n">power_of_two</span>
    <span class="k">return</span> <span class="n">binary_representation</span>

<span class="nb">print</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="n">integer_to_binary</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">integer_to_binary</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>16 10000
3 11
</pre></div>
</div>
</div>
</div>
<p>Looks pretty good!  But does it hold up to a lot of cases?  Can we establish some level of confidence in our algorithm?</p>
<p>Let’s write a sequential test to see!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">strip_leading</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">test_integer_to_binary</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5000</span><span class="p">):</span>
        <span class="n">python_version</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">python_version</span> <span class="o">=</span> <span class="n">strip_leading</span><span class="p">(</span><span class="n">python_version</span><span class="p">)</span>
        <span class="n">our_version</span> <span class="o">=</span> <span class="n">integer_to_binary</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">our_version</span> <span class="o">==</span> <span class="n">python_version</span>

<span class="n">test_integer_to_binary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ValueError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">21</span><span class="o">-</span><span class="n">dd36bfff8999</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span>         <span class="k">assert</span> <span class="n">our_version</span> <span class="o">==</span> <span class="n">python_version</span>
<span class="g g-Whitespace">     </span><span class="mi">10</span> 
<span class="ne">---&gt; </span><span class="mi">11</span> <span class="n">test_integer_to_binary</span><span class="p">()</span>

<span class="nn">&lt;ipython-input-21-dd36bfff8999&gt;</span> in <span class="ni">test_integer_to_binary</span><span class="nt">()</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span>         <span class="n">python_version</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">7</span>         <span class="n">python_version</span> <span class="o">=</span> <span class="n">strip_leading</span><span class="p">(</span><span class="n">python_version</span><span class="p">)</span>
<span class="ne">----&gt; </span><span class="mi">8</span>         <span class="n">our_version</span> <span class="o">=</span> <span class="n">integer_to_binary</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span>         <span class="k">assert</span> <span class="n">our_version</span> <span class="o">==</span> <span class="n">python_version</span>
<span class="g g-Whitespace">     </span><span class="mi">10</span> 

<span class="nn">&lt;ipython-input-16-c529c6319b11&gt;</span> in <span class="ni">integer_to_binary</span><span class="nt">(number)</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> 
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="k">def</span> <span class="nf">integer_to_binary</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
<span class="ne">----&gt; </span><span class="mi">4</span>     <span class="n">biggest_power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span>     <span class="k">if</span> <span class="n">biggest_power_of_two</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">):</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span>         <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>

<span class="ne">ValueError</span>: math domain error
</pre></div>
</div>
</div>
</div>
<p>So we found an error with our implementation - we can’t take the log of 0.  This means our test found an issue we cannot reconcile with our implementation.  However, since 0 in binary is just 0 we can cover this with a special case:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">integer_to_binary</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;0&#39;</span>
    <span class="n">biggest_power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">biggest_power_of_two</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">):</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>
    <span class="n">binary_representation</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power_of_two</span> <span class="o">&gt;</span> <span class="n">number</span><span class="p">:</span>
            <span class="n">binary_representation</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binary_representation</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
            <span class="n">number</span> <span class="o">-=</span> <span class="n">power_of_two</span>
    <span class="k">return</span> <span class="n">binary_representation</span>
</pre></div>
</div>
</div>
</div>
<p>Now we can rerun our test:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">test_integer_to_binary</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>And we pass!  Because this runs, at least on the author’s machine in under a second, let’s try to extend the range a bit!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_integer_to_binary</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500000</span><span class="p">):</span>
        <span class="n">python_version</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">python_version</span> <span class="o">=</span> <span class="n">strip_leading</span><span class="p">(</span><span class="n">python_version</span><span class="p">)</span>
        <span class="n">our_version</span> <span class="o">=</span> <span class="n">integer_to_binary</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">our_version</span> <span class="o">==</span> <span class="n">python_version</span>
        
<span class="n">test_integer_to_binary</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We still pass!  And rather quickly.  Looks like we’ve written some rather efficient and correct code!  And we were able to ensure it works for the first 500000 integers!  That’s pretty good.  We can now safely use our efficient code freely on <em>any</em> of these cases with confidence.  Which is the power of testing.  Of course, did we <em>need</em> to test every single one of these numbers?  If our algorithm worked on 2500, should we expect it to work on 2501?</p>
<p>In some cases, the answer will be no.  Sometimes checking some <em>random</em> cases is enough, as long as we check enough of them.  For this, we’ll need a notion of computational randomness.  And for that we’ll need to introduce some basic probability, distributions, and random seeds, otherwise known as initial conditions for generating random numbers.</p>
</div>
</div>
<div class="section" id="introduction-to-randomness">
<h2>Introduction To Randomness<a class="headerlink" href="#introduction-to-randomness" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>probability basics</p></li>
<li><p>distributions</p></li>
<li><p>random seeds</p></li>
</ul>
<div class="section" id="probability-basics">
<h3>Probability basics<a class="headerlink" href="#probability-basics" title="Permalink to this headline">¶</a></h3>
<p>Probability is the study of uncertainty.  Using probability we can answer questions about how likely an event is to occur.  To begin our analysis of probability we will first look at a very important function - the counting function.  This function will allow us to <em>count the number of elements of a set</em>.  Let’s look at an example:</p>
<p>Suppose A = {1,2,3}, then <span class="math notranslate nohighlight">\(|A| = 3\)</span>, here <span class="math notranslate nohighlight">\(|A|\)</span> is the count of the set A.</p>
<p>Let’s look at some important trivial cases:</p>
<p>If A = <span class="math notranslate nohighlight">\(\emptyset\)</span>, then <span class="math notranslate nohighlight">\(|A| = 0\)</span>.</p>
<p>If A = <span class="math notranslate nohighlight">\(\mathbb{N}\)</span>, then <span class="math notranslate nohighlight">\(|A| = \infty\)</span></p>
<p>Now let’s look at how the counting function works with respect to our set operators:</p>
<p>If A, B are sets, such that <span class="math notranslate nohighlight">\(A \neq \emptyset\)</span>, <span class="math notranslate nohighlight">\(B \neq \emptyset\)</span>, then,</p>
<div class="math notranslate nohighlight">
\[|(A\text{ } \cup \text{ } B)| = |A| + |B|, such \text{ } that A \cap B = \emptyset\]</div>
<p>More generally speaking, there exists a theorem called the partition principal that says:</p>
<p>If <span class="math notranslate nohighlight">\(A_{1}, A_{2}, .. A_{n}\)</span> are all non-empty non-overlapping subsets of a set C, then,</p>
<div class="math notranslate nohighlight">
\[ |C| = |A_{1}| + |A_{2}| + ... + |A_{n}| \]</div>
<p>Note that, because <span class="math notranslate nohighlight">\(A_{i}, A_{j}\)</span> non-overlapping, <span class="math notranslate nohighlight">\(A_{i} \cap A_{j} = \emptyset\)</span></p>
<p>As a corollary, notice that if we have a set A, such that <span class="math notranslate nohighlight">\(A \subseteq C\)</span> and <span class="math notranslate nohighlight">\(A \neq \emptyset\)</span> then <span class="math notranslate nohighlight">\(A, \bar{A}\)</span> form a natural partition of <span class="math notranslate nohighlight">\(C\)</span>.  Therefore,</p>
<div class="math notranslate nohighlight">
\[|C| = |A| + |\bar{A}|\]</div>
<p>Also,</p>
<div class="math notranslate nohighlight">
\[|C| - |A| = |\bar{A}|\]</div>
<p>Other identities that are presented without proof include:</p>
<div class="math notranslate nohighlight">
\[|A| = |(A \cap B)| + |(A \cap \bar{B})|\]</div>
<div class="math notranslate nohighlight">
\[|A| - |(A \cap B)| = |(A \cap \bar{B})|\]</div>
<p>Also, it is possible to derive</p>
<div class="math notranslate nohighlight">
\[ |(A \cup B)| = |A| + |B| - |(A \cap B)| \]</div>
<p>from the above set of identities.</p>
<p>Now that we have some identities that we can make use of, let’s begin discussing probability.</p>
<p>The first concept we will need is that of the sample space:</p>
<p>Definition -</p>
<p>A sample space is the set of all possible outcomes of a random phenomenon.</p>
<p>Examples of random phenomena include:</p>
<ul class="simple">
<li><p>tossing a coin</p></li>
<li><p>rolling a dice</p></li>
<li><p>choosing a card from a deck</p></li>
</ul>
<p>One common theme for all of these examples, we cannot predict with certainty what will happen next, that is, we cannot treat these phenomena like the inputs and outputs of a function, or an algorithm.  But we can assess write down all the things that <em>might</em> happen.</p>
<p>For the toss of a coin there are two possible results:</p>
<ul class="simple">
<li><p>Heads</p></li>
<li><p>Tails</p></li>
</ul>
<p>Therefore our sample space for a single flip is just the set {H, T} (H for heads, T for tails).</p>
<p>For the rolling of a dice the sample space is the numbers = {1,2,3,4,5,6}.</p>
<p>And for the choosing of a card, we have 52 possabilities in a standard french deck.</p>
<p>In each of these cases, it is possible to write down <em>all</em> of the possible outcomes.</p>
<p>We are now ready to begin defining probability:</p>
<p>Let S be a sample space and let E be an event, a specific element from element or ‘occurrence’ from the sample space, then the probability of an event E in S be P(E).  Probabilities of events in a sample space will always be required to obey the following axioms:</p>
<p>Axiom 1.  The probability of an event is always a non-negative number, therefore</p>
<div class="math notranslate nohighlight">
\[ P(E) \ge 0 \]</div>
<p><span class="math notranslate nohighlight">\(\forall\)</span>E in S.</p>
<p>Axiom 2. If the sample space is S, then</p>
<div class="math notranslate nohighlight">
\[ P(S) = 1\]</div>
<p>Axiom 3.  If <span class="math notranslate nohighlight">\(A_{1}, A_{2}, .. A_{n}\)</span> are all non-empty non-overlapping subsets of a set S, then,</p>
<div class="math notranslate nohighlight">
\[ P(S) = P(A_{1}) + P(A_{2}) + ... + P(A_{n}) \]</div>
<p>Note that, because <span class="math notranslate nohighlight">\(A_{i}, A_{j}\)</span> non-overlapping, <span class="math notranslate nohighlight">\(A_{i} \cap A_{j} = \emptyset\)</span></p>
<p>If axiom 3 looks familiar, that’s because it should!  It’s the same as the identity we learned about earlier, except, instead of a counting function <span class="math notranslate nohighlight">\(|*|\)</span>, we replaced it with <span class="math notranslate nohighlight">\(P()\)</span>, the probability function.</p>
<p>Now that we have a notion of a probability function, we can define how to calculate the probability <em>from</em> the counting function.</p>
<p>Let <span class="math notranslate nohighlight">\(E\)</span> be an event in a sample space <span class="math notranslate nohighlight">\(S\)</span>, then</p>
<div class="math notranslate nohighlight">
\[ P(E) = \frac{|E|}{|S|} \]</div>
<p>Now, let’s see how to apply our new formula to the above three examples.  Let’s begin with a coin flip -</p>
<p>What is the probability of getting heads?</p>
<p>Well, it’s,</p>
<div class="math notranslate nohighlight">
\[P(H) = \frac{|\{H\}|}{|\{H, T\}|}\]</div>
<p>In other words,</p>
<div class="math notranslate nohighlight">
\[P(H) = \frac{1}{2}\]</div>
<p>Next, let’s turn our attention to the probability of rolling two six sided dice and getting a 12.</p>
<p>For this, we will need to consider the cartesian product of the two dice to get the full sample space, that is:</p>
<p>{1,2,3,4,5,6} x {1,2,3,4,5,6}.</p>
<p>We can use Python to get the full size of the sample space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sample_space_two_dice</span><span class="p">():</span>
    <span class="n">sample_space</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">):</span>
            <span class="n">sample_space</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">sample_space</span>

<span class="n">sample_space</span> <span class="o">=</span> <span class="n">sample_space_two_dice</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can see that the size of the sample space is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">sample_space</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>36
</pre></div>
</div>
</div>
</div>
<p>Here are a few of the events:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sample_space</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(1, 1), (1, 2), (1, 3)]
</pre></div>
</div>
</div>
</div>
<p>As you can see, we take the first element of our cartesian product from the sample space of the first die and our second from the sample space of the second die.  Finally, our total sample space should look familiar - the number 36 is actually the <em>product</em> of 6 * 6, which is the size of our two sample spaces!</p>
<p>This is no accident, in fact, that’s part of why a cartesian product is called <em>a product</em>.  Because it <em>is</em> a multiplication.</p>
<p>In general:</p>
<p>if A, B are sets such that <span class="math notranslate nohighlight">\(A \neq \emptyset\)</span>, <span class="math notranslate nohighlight">\(B \neq \emptyset\)</span>, we have</p>
<p>$<span class="math notranslate nohighlight">\(|A x B| = |A| x |B|\)</span>$.</p>
<p>Moving on, now that we have the size of the sample space, we simply need the number of occurrences of (6,6):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">sample_space</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">event</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        
<span class="n">count</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1
</pre></div>
</div>
</div>
</div>
<p>As you can see, the pair (6,6) only occurs once!  So, our probability is:</p>
<div class="math notranslate nohighlight">
\[ P(\{(6,6)\}) = \frac{1}{36} \]</div>
<p>Just to be clear, what would the probability of rolling a 3 and a 4?  Is it still <span class="math notranslate nohighlight">\(\frac{1}{36}\)</span>?  We can figure that out by just counting up the occurrences in the sample space:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">sample_space</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">event</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">count</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2
</pre></div>
</div>
</div>
</div>
<p>Therefore our probability is <span class="math notranslate nohighlight">\(\frac{2}{36}\)</span></p>
<p>Notice, the reason we have to count (3,4) and (4,3) is because we <em>never</em> specified what order the dice had to appear in.  Nor is there any notion of the dice being rolled sequentially.  Typically, when rolling dice, you do it together or <em>simultaneously</em>.  Therefore there is no notion of event ordering, and thus you must account for both cases.</p>
<p>Finally, we can also figure out the probability of rolling a total score of 5 between the two dice:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">sample_space</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">count</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>4
</pre></div>
</div>
</div>
</div>
<p>Here our probability is <span class="math notranslate nohighlight">\(\frac{4}{36}\)</span></p>
<p>Next let’s look at another classic problem in probability -</p>
<p>Suppose you had 5 letters - a,b,c,d,e.  Using these letters, how could you come up with all the possible 3 letter strings?</p>
<p>We could solve this with looping:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">possible_strings</span><span class="p">():</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">]</span>
    <span class="n">permutations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">one</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">two</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">three</span> <span class="ow">in</span> <span class="n">letters</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">one</span> <span class="o">==</span> <span class="n">two</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">one</span> <span class="o">==</span> <span class="n">three</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">two</span> <span class="o">==</span> <span class="n">three</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">permutations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">,</span> <span class="n">three</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">permutations</span>

<span class="n">strings</span> <span class="o">=</span> <span class="n">possible_strings</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that with a permutation once we select an element to be a member of our string, we cannot select it again.  That’s why we need the continue statements above.  In general, this is called sampling without replacement.  We can think of our small set of letters sort of like a sample space or bag.  And once we pull an element out of our bag, we do not put it back in our bag.  Or in other words, we don’t <em>replace it</em> in our bag of possible letters.</p>
<p>Let’s look at a subset of these:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strings</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;b&#39;, &#39;d&#39;), (&#39;a&#39;, &#39;b&#39;, &#39;e&#39;)]
</pre></div>
</div>
</div>
</div>
<p>Seems reasonable enough.  How big is the sample space?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">strings</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>60
</pre></div>
</div>
</div>
</div>
<p>Woah!  That’s a lot of possible events.  If we want to calculate this for any reasonable event spaces, it would be helpful to have a short hand.  For starters, a tripple for-loop isn’t exactly performant.  And as the size of the strings increases, this will get <em>even</em> worse.  If we wanted all the 5 letter strings we would need 5 for loops!  For every new element in the string, we need a new <em>nested</em> for loop.  And that adds up very quick.</p>
<p>So our sample space grows <em>fast</em> with the length of the string.  <em>Not great</em>.</p>
<p>In order to deal with this, we’ll make use of a formula for calculating permutations, for this, we’ll need to introduce the factorial, which we can calculate generally using recursion or dynamic programming.  Because we plan on formally introducing recursion later on, we’ll use the dynamic programming version, which doesn’t any new concepts, but uses things we already know in a <em>clever</em> and somewhat confusing fashion.  We will also provide a formal introduction to dynamic programming in a later chapter.  But for now, let’s just view the code for calculating a factorial:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">listing</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">listing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">listing</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">listing</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="n">factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3628800
</pre></div>
</div>
</div>
</div>
<p>In general, the formula for n factorial, usually denoted by <span class="math notranslate nohighlight">\(n!\)</span> is,</p>
<div class="math notranslate nohighlight">
\[n! = 1 * 2 * 3 * 4 *\text{ } ...\text{ } * n\]</div>
<p>We can use the factorial to define the permutation without having to do <em>n-many</em> for loops:</p>
<div class="math notranslate nohighlight">
\[p(n, r) = \frac{n!}{(n - r)!}\]</div>
<p>Here n is the number of elements to choose from and r is the number of spaces available.  So for a string with 5 possible choices for each place and 3 possible places we get:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">permutation</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span>

<span class="n">permutation</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>60.0
</pre></div>
</div>
</div>
</div>
<p>Now that we’ve seen how to easily calculate the sample space for a permutation, or sampling without replacement, what if we were allowed to replace our elements?  Then we’d be in the above case dealing with cartesian products, and our sample space would be</p>
<div class="math notranslate nohighlight">
\[n^{r}\]</div>
<p>That is,</p>
<div class="math notranslate nohighlight">
\[\{the\text{ }number\text{ }of\text{ }possible\text{ }elements\}^{ \{the\text{ }size\text{ }of\text{ }the\text{ }string\} }\]</div>
<p>The final formula we will look at in this section to get a sample space is to look at combinations.  Combinations are particularly useful when dealing with defining probabilities with things like cards.  For instance, what’s the probability of selecting a red jack?</p>
<p>For this we can use combination:</p>
<p>A combination “selects” or “chooses” a property within a set of properties.  In other words, if we have a bunch of things and we have different attributes associated with different subsets of the things, we can count how many ways we can get that attribute.</p>
<p>First, let’s describe the formula for combination:</p>
<div class="math notranslate nohighlight">
\[ {n \choose r} = \frac{n!}{r!(n - r)!} \]</div>
<p>Above, <span class="math notranslate nohighlight">\({n \choose r}\)</span> is read, “n choose r”.</p>
<p>Now let’s calculate our probability:</p>
<div class="math notranslate nohighlight">
\[{52 \choose 1} = \frac{52!}{1! * 51!} \]</div>
<p>This is because there are 52 cards in the deck and we are selecting one of them.  So our denominator is 52.</p>
<p>As for our numerator:</p>
<p>We first choose the color:</p>
<div class="math notranslate nohighlight">
\[{ 2 \choose 1} = \frac{2!}{1! * 1!} = 2 \]</div>
<p>Next we choose a jack, which is:</p>
<div class="math notranslate nohighlight">
\[{ 1 \choose 1} = \frac{1!}{1! * 0!} = 1 \]</div>
<p>The reason this final “choice” is <span class="math notranslate nohighlight">\({1 \choose 1}\)</span> is because there is only <em>one</em> way to choose a jack from amongst the 13 choices of card numbers.</p>
<p>So we have <span class="math notranslate nohighlight">\(\frac{2 * 1}{52} = \frac{2}{52}\)</span> for our probability.</p>
<p>Let’s look at a more interesting card example.  Next, let’s calculate how many ways we can get an <em>even</em> card selected from a standard deck.  Note, for this example, we won’t need an denominator.</p>
<p>We first must choose a color, which will be:</p>
<div class="math notranslate nohighlight">
\[{ 4 \choose 1} = \frac{4!}{1! * 1!} = 4 \]</div>
<p>Next we select an even:</p>
<div class="math notranslate nohighlight">
\[{13 \choose 5} = \frac{13!}{5! * 8!} = \frac{13*12*11*10*9}{5*4*3*2} = 13*11*9\]</div>
<p>For the final step, we’ll use Python :)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">13</span> <span class="o">*</span> <span class="mi">11</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">*</span> <span class="mi">4</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5148
</pre></div>
</div>
</div>
</div>
<p>So there are 5148 ways we can get an even card.  Note the 4 in the above calculation is from the first step.</p>
<p>Now that we have a good generic solution for counting things.  To review our formulas are:</p>
<ul class="simple">
<li><p>permutations (sampling without replacement):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[p(n, r) = \frac{n!}{(n - r)!}\]</div>
<ul class="simple">
<li><p>permutations (sampling with replacement):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[n^{r}\]</div>
<ul class="simple">
<li><p>combinations:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ {n \choose r} = \frac{n!}{r!(n - r)!} \]</div>
<p>Using one of these three formulas, depending on the type of selection we are doing, we can “count” the number of events of interest and the sample space with relative ease.  Thus we can calculate many classes of probabilities in a straight forward manor.</p>
<p>However, what happens when we want to know the probability of an event that <em>depends</em> on another event?  For instance, what is the probability it will rain, is very different than asking, what is the probability it will rain given that the dew point is 38 degrees?</p>
<p>What we are saying from the above is that the event it will rain is related, or <em>conditional</em> on the dew point.  And that whether or not the dew point is 38 degrees will change the chance it will rain.  In general, this sort of computation is called calculating the conditional probability.</p>
<p>The following formula is generally used to do such a calculation:</p>
<div class="math notranslate nohighlight">
\[ P(A | B) = \frac{P(A \cap B)}{P(B)} \]</div>
<p>Recall that for discrete cases, the intersection <span class="math notranslate nohighlight">\(A \cap B\)</span> is just:</p>
<div class="math notranslate nohighlight">
\[\frac{|(A \cap B)|}{|S|}\]</div>
<p>where is is the total sample space.</p>
<p>Since <span class="math notranslate nohighlight">\(P(B)\)</span> also depends on <span class="math notranslate nohighlight">\(|S|\)</span>, we can actually look at a simplication:</p>
<div class="math notranslate nohighlight">
\[ P(A | B) = \frac{P(A \cap B)}{P(B)} = \frac{\frac{|(A \cap B)|}{|S|}}{\frac{|B|}{|S|}} = \frac{|(A \cap B)|}{|B|}\]</div>
<p>So when calculating the conditional probability, we don’t need to consider the the sample space at all!</p>
<p>Let’s look at an example:</p>
<p>Say you are playing a guessing game, where you and an opponent must take turns guessing cards.  Specifically, your opponent draws a card and then tells you something about the card.  From there you need to deduce a second property about the card.</p>
<p>Let’s assume your opponent tells you the card is a club, from there you want to state the characteristic that is most likely, that you cannot automatically deduce.  Here are some properties, with their calculated probabilities:</p>
<ol class="simple">
<li><p>That the card is even:</p></li>
</ol>
<p>For this we need to notice that 2,4,6,8,10 are the even numbers.  Since we know that it’s a club we may be tempted to say that the probability is:</p>
<div class="math notranslate nohighlight">
\[ \frac{5}{13} \]</div>
<p>Chance of it being even.</p>
<p>Let’s see if our formula yields the same answer:</p>
<p>We begin by calculating the individual proabilities:</p>
<ul class="simple">
<li><p>P(A) - card is even - <span class="math notranslate nohighlight">\(\frac{20}{52}\)</span></p></li>
<li><p>P(B) - card is club - <span class="math notranslate nohighlight">\(\frac{13}{52}\)</span></p></li>
<li><p>P(<span class="math notranslate nohighlight">\(A \cap B\)</span>) - card is even and a club -  <span class="math notranslate nohighlight">\(\frac{5}{13}\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[ P(A | B) = \frac{P(A \cap B)}{P(B)} = \frac{\frac{5}{13}}{\frac{13}{52}} = \frac{5}{52} \]</div>
<p>So in fact our conditional probability was different!  How is conditional different than intersection?  With intersection we are assuming our events happen in sequence.  So by having information ahead of time, we are able to say something different.  Essentially what we are talking about here is a <em>dependence structure</em>.  When events are <em>related</em> or their intersection is non-zero, then the available information matters.</p>
<p>Next let’s consider the probability of the card being a face card, given that it is clubs:</p>
<p>We begin by calculating the individual proabilities:</p>
<ul class="simple">
<li><p>P(A) - card is a face - <span class="math notranslate nohighlight">\(\frac{12}{52}\)</span></p></li>
<li><p>P(B) - card is club - <span class="math notranslate nohighlight">\(\frac{13}{52}\)</span></p></li>
<li><p>P(<span class="math notranslate nohighlight">\(A \cap B\)</span>) - card is face and a club -  <span class="math notranslate nohighlight">\(\frac{3}{13}\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[ P(A | B) = \frac{P(A \cap B)}{P(B)} = \frac{\frac{3}{13}}{\frac{13}{52}} = \frac{3}{52} \]</div>
<p>This result should be unsurprising, since there are more even cards than face cards.</p>
<p>Finally, let’s look at calculating the probability for a card being a 6 given that it is a club:</p>
<p>We begin by calculating the individual proabilities:</p>
<ul class="simple">
<li><p>P(A) - card is 6 - <span class="math notranslate nohighlight">\(\frac{4}{52}\)</span></p></li>
<li><p>P(B) - card is club - <span class="math notranslate nohighlight">\(\frac{13}{52}\)</span></p></li>
<li><p>P(<span class="math notranslate nohighlight">\(A \cap B\)</span>) - card is a 6 and a club -  <span class="math notranslate nohighlight">\(\frac{1}{13}\)</span></p></li>
</ul>
<div class="math notranslate nohighlight">
\[ P(A | B) = \frac{P(A \cap B)}{P(B)} = \frac{\frac{1}{13}}{\frac{13}{52}} = \frac{1}{52} \]</div>
<p>This last one <em>should</em> line up with your intuition in a clear enough way, because there is exactly 1 6 of clubs in a standard french deck.</p>
<p>Now that we’ve seen how probabilities are calculated when there is a clear <em>dependence relationship</em> between events, what happens if the opposite is true, that is what if events are <em>independent</em>?</p>
<p>In this case, the <span class="math notranslate nohighlight">\(P(A|B) = P(A)\)</span> because <span class="math notranslate nohighlight">\(P(A \cap B) = P(A) * P(B)\)</span>, therefore <span class="math notranslate nohighlight">\(P(A|B) = \frac{P(A)*P(B)}{P(B)}\)</span>.  For events to be independent, is the same thing as the events <em>not being related</em>.</p>
<p>We are now in a place to talk about our first <em>distribution</em>.</p>
</div>
<div class="section" id="distributions">
<h3>Distributions<a class="headerlink" href="#distributions" title="Permalink to this headline">¶</a></h3>
<p>Consider a simple scenario - you wish you know the probability of getting heads or tails for a coin flip.  We can calculate that easy enough -</p>
<div class="math notranslate nohighlight">
\[ P(H) = \frac{1}{2} = P(T) \]</div>
<p>That is, there is a 50% chance of getting heads and a 50% chance of getting tails.  But does that mean every flip of a coin where we get heads is followed by tails?  Certainly not!  The probability is sort of like a short hand or the <em>asymptotic</em> behavior of an event with <em>predictable</em> outcomes.  A predictable system is one in which we don’t know any given occurrence for the next experimental trial, but in general, we can figure out how the trial will behave over a large enough iterations.  In other words, there is choas or uncertainty in <em>any</em> given coin flip, but there is consistency in the pattern as we tail up more and more coin flips.</p>
<p>Because we have a computer, we don’t need to actually do the coin flips ourselves.  Let’s create an experiment where we flip coins until we get the ideal probability, or at least verify that this is truly what will happen:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">flip_coins</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="n">sample_space</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">]</span>
    <span class="n">heads_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tails_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">heads_percent</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tails_percent</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sample_space</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span>
            <span class="n">heads_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tails_count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">heads_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">heads_percent</span> <span class="o">=</span> <span class="n">heads_count</span><span class="o">/</span><span class="n">n</span>
    <span class="k">if</span> <span class="n">tails_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">tails_percent</span> <span class="o">=</span> <span class="n">tails_count</span><span class="o">/</span><span class="n">n</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;percent_heads&quot;</span><span class="p">:</span> <span class="n">heads_percent</span><span class="p">,</span>
        <span class="s2">&quot;percent_tails&quot;</span><span class="p">:</span> <span class="n">tails_percent</span>
    <span class="p">}</span>

<span class="k">def</span> <span class="nf">visualize_flips_over_trials</span><span class="p">():</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">num_trials</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flip_coins</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">heads</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;percent_heads&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
    <span class="n">tails</span> <span class="o">=</span> <span class="p">[</span><span class="n">elem</span><span class="p">[</span><span class="s2">&quot;percent_tails&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">results</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">heads</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">tails</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;darkorange&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="n">visualize_flips_over_trials</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Counterexamples_and_Testing_67_0.png" src="../../_images/Counterexamples_and_Testing_67_0.png" />
</div>
</div>
<p>As you can see, we get pretty close to 50% for both heads and tails, we could keep running these trials and eventually it would get so close to 50% for each, you wouldn’t tell the difference.  If we could take the trials to infinity, then it would go to strictly <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span> for both.</p>
<p>Next we can extend this first discrete, honestly kinda boring distribution to a second more interesting discrete distribution - what happens when we want to know <em>predict the composition of the n trials</em>.  That is, can we figure out the probability that we would get 11 heads and 9 tails in 20 trials?</p>
<p>It turns out we can!  In fact there is a neat formula we can use:</p>
<div class="math notranslate nohighlight">
\[ {n \choose k} p^{k} * q^{n - k} \]</div>
<p>Here n is the number of trials, k is the number of successes, p is the probability of success, q is the probability of failure.  So for 30 flips of a fair coin with 10 heads and heads being the success case, we can expect that to occur with probability:</p>
<div class="math notranslate nohighlight">
\[ {30 \choose 10} * \frac{1}{2}^{10} * \frac{1}{2}^{20} \]</div>
<p>We’ll use Python to reduce this to something clearer:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">combination</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span>

<span class="n">combination</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.02798160072416067
</pre></div>
</div>
</div>
</div>
<p>Wow!  Looks like it’s <em>super</em> unlikely we would only get 10 heads.  What if we split them evenly?</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combination</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.14446444809436798
</pre></div>
</div>
</div>
</div>
<p>Well that’s certainly a lot <em>more</em> likely, but still not that likely, especially given the asymptotic behavior of a coin flip.  Let’s increase the number of trials but stick with the 50% going to heads and 50% going to tails:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combination</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0252250181783608
</pre></div>
</div>
</div>
</div>
<p>What’s happening here is the <span class="math notranslate nohighlight">\(\frac{1}{2}^{500}\)</span> is dominating the equation, because <span class="math notranslate nohighlight">\({1000 \choose 500}\)</span> is:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combination</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2.7028824094543655e+299
</pre></div>
</div>
</div>
</div>
<p>A <em>very</em> big number, but <span class="math notranslate nohighlight">\(\frac{1}{2}^{500}\)</span> is a <em>very small number</em>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3.054936363499605e-151
</pre></div>
</div>
</div>
</div>
<p>And we are multiplying a very big number by <em>2</em> small numbers, so the small numbers have a compounding effect.  Interestingly if we decrease the number of trials to 2 we get:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combination</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.5
</pre></div>
</div>
</div>
</div>
<p>Which agrees with our theoretical asymptotic behavior.  The reason the numbers don’t act how you expect anymore is because we are being <em>precise</em>.  We aren’t asking for approximately 500 head flips in 1000 trials, we are asking for <em>exactly</em> 500 head flips in 1000 trials.  Since we are using a combination, we don’t care about the <em>order</em> of those 500 heads, but there must be <em>exactly</em> 500.  This is why our probabilities get so small as our number of trials increase.  You can think of each trial as segmenting the sample space a little bit more.  For instance, let’s suppose we started with small numbers:</p>
<p>Say we wanted the probability of 3 heads from 5 trials, what does that sample space look like now?</p>
<p>Because it’s a lot to write, we’ll just look at one ‘row’:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sample</span> <span class="n">Space</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">),</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">),</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">),</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">H</span><span class="p">),</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">H</span><span class="p">),</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">T</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In total our sample space contains <span class="math notranslate nohighlight">\(5^{2} = 25\)</span> possible cases.  Recall that a single trial only has a sample space of 2 - so with only an increase of 4 trials, we’ve increased our sample space 12 fold.  That’s alot!  As our number of trials increases, the size of our sample space increases <em>exponentially</em>.  That’s why the probabilities get so small in our formula as the number of trials increases.</p>
<p>There is one last feature that’s embedded in this formula - all of the trials are <em>independent</em> that’s why we can take <em>combinations</em>.  If there was a dependence structure then formula wouldn’t apply.  This means, we can apply this formula to <em>any</em> trials where the probability of the outcomes for a given event are known, and the trials are independent.</p>
<p>Therefore we can think of this formula:</p>
<div class="math notranslate nohighlight">
\[ {n \choose k} p^{k} * q^{n - k} \]</div>
<p>As a <em>model</em> for any trials with two indepedent cases with known individual probabilities.  This model allows us to characterize more than the individual probabilities for a given event, by iterating over n and k, we can see the forest, we can see the ‘shape’ of the probability over the entire event space as the number of trials increases:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">probability</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">p</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">combination</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_shape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">probability</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">probabilities</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">15</span><span class="p">):</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">get_shape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Counterexamples_and_Testing_81_0.png" src="../../_images/Counterexamples_and_Testing_81_0.png" />
<img alt="../../_images/Counterexamples_and_Testing_81_1.png" src="../../_images/Counterexamples_and_Testing_81_1.png" />
<img alt="../../_images/Counterexamples_and_Testing_81_2.png" src="../../_images/Counterexamples_and_Testing_81_2.png" />
<img alt="../../_images/Counterexamples_and_Testing_81_3.png" src="../../_images/Counterexamples_and_Testing_81_3.png" />
<img alt="../../_images/Counterexamples_and_Testing_81_4.png" src="../../_images/Counterexamples_and_Testing_81_4.png" />
<img alt="../../_images/Counterexamples_and_Testing_81_5.png" src="../../_images/Counterexamples_and_Testing_81_5.png" />
</div>
</div>
<p>As you can see, the individual probabilities get closer and close to 0 as the number of trials increases.  Is this always true?  What about if our probabilities were <em>very lopsided</em>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">15</span><span class="p">):</span>
    <span class="n">probabilities</span> <span class="o">=</span> <span class="n">get_shape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Counterexamples_and_Testing_83_0.png" src="../../_images/Counterexamples_and_Testing_83_0.png" />
<img alt="../../_images/Counterexamples_and_Testing_83_1.png" src="../../_images/Counterexamples_and_Testing_83_1.png" />
<img alt="../../_images/Counterexamples_and_Testing_83_2.png" src="../../_images/Counterexamples_and_Testing_83_2.png" />
<img alt="../../_images/Counterexamples_and_Testing_83_3.png" src="../../_images/Counterexamples_and_Testing_83_3.png" />
<img alt="../../_images/Counterexamples_and_Testing_83_4.png" src="../../_images/Counterexamples_and_Testing_83_4.png" />
<img alt="../../_images/Counterexamples_and_Testing_83_5.png" src="../../_images/Counterexamples_and_Testing_83_5.png" />
</div>
</div>
<p>It’s even worse if our probabilities are lopsided!  Anywho, there are lots of fun things you can do with distributions - if your distribution is a good model of the underlying thing, then you can use the distribution to run experiments on your computer, and you can learn about the real world!  Pretty neat, right?!</p>
<p>There are some other classes of events you should be aware of:</p>
<ul class="simple">
<li><p>those that follow the normal distribution</p></li>
<li><p>those that follow the poisson distribution</p></li>
<li><p>those that doesn’t follow any distribution</p></li>
</ul>
<p>The first two distributions are <em>continuous</em> distributions, meaning they are modeled using real valued functions, and that they are good for modeling things can’t be easily broken up into discrete events.  Typically with continuous random variables you talk about the probability of something happening below or above a threshold, or between two thresholds or outside two thresholds.  So for instance, suppose X was a continuous random variable then we might ask:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P(X &lt; 5)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P(X &gt; 10)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P(5 &lt; X &lt; 25)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P(X &lt; 5 \text{ } or \text{ } X &gt; 15)\)</span></p></li>
</ul>
<p>The formula for the normal distribution is:</p>
<div class="math notranslate nohighlight">
\[ f(x) = \frac{1}{\sigma \sqrt{2\pi}} e^{-\frac{1}{2}(\frac{x-\mu}{\sigma})^{2}} \]</div>
<p>Not an easy formula to understand!</p>
<p>Here the parameter <span class="math notranslate nohighlight">\(\mu\)</span> stands for the central tendency of the distribution, which in the case of the normal distribution is the arithmetic mean.</p>
<p>The parameter <span class="math notranslate nohighlight">\(\sigma\)</span> stands for the spread of the distribution, which in the case of the normal distribution is the variance.</p>
<p>Here x is just a parameter to the function.</p>
<p>Everything else is just a constant.</p>
<p>By plugging all of these things into the equation, we are able to reconstruct <em>any</em> normal distribution.  Let’s look at an example:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Counterexamples_and_Testing_85_0.png" src="../../_images/Counterexamples_and_Testing_85_0.png" />
</div>
</div>
<p>As you can see, the data is ‘centered’ around 0, which is the first parameter passed into the function <code class="docutils literal notranslate"><span class="pre">np.random.normal</span></code>, this is the central tendency <span class="math notranslate nohighlight">\(\mu\)</span>.  The second parameter gives us a sense of the spread - this is the parameter <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>We don’t typically need to pass in the parameter x in Python, that variable is <em>implicit</em> to the formula.  We can also generate data that follows a poisson random variable just as easily:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/Counterexamples_and_Testing_87_0.png" src="../../_images/Counterexamples_and_Testing_87_0.png" />
</div>
</div>
<p>Notice that a poisson random variable only depends on one parameter instead of two.  The distribution of data it generates is different, because there is a different underlying model.  The poisson variable is distributed according to this formula:</p>
<div class="math notranslate nohighlight">
\[ P(x, \mu) = \frac{e^{-\mu}(\mu^{x})}{x!} \]</div>
<p>Here x is just the data being passed in.</p>
<p>The <span class="math notranslate nohighlight">\(\mu\)</span> on the other hand, has a more interesting meaning, specifically it is the expected number of occurrences of the event over a given period.  Typically poisson random variables are used to measure events per time unit, like per minute or per hour or per year.  So if we expect 5 occurrences per hour, for instance, we can tell how many events are likely to occur - the above graph shows the likelihood of the number of events of interest occurring over a typical hour.  Notice that at 5 we have the densed count - because we <em>expect</em> 5 events.  However, that doesn’t mean that 4, or 6 events couldn’t occur within the next hour.  However it is unlikely that 9 or 10 events.</p>
<p>The way we create random or psuedo random numbers is fascinating, but honestly is <em>a lot to explain</em> and this introductory chapter is already getting <em>very long</em>.  For those of you interested in how to generate numbers that don’t follow a distribution please check out: <a class="reference external" href="https://www.youtube.com/watch?v=ovJcsL7vyrk&amp;t=549s&amp;ab_channel=Veritasium">https://www.youtube.com/watch?v=ovJcsL7vyrk&amp;t=549s&amp;ab_channel=Veritasium</a> - in general Veritasium is a great channel and highly recommended by the author.</p>
<p>Note: This section takes part of it’s inspiration from “Introduction to Probability” by Nelson Markley.</p>
</div>
</div>
<div class="section" id="random-testing">
<h2>Random Testing<a class="headerlink" href="#random-testing" title="Permalink to this headline">¶</a></h2>
<p>Now that we’ve covered distributions, we can make use of them to inform testing.  Recall the simple sort algorithm we introduced at the beginning of the chapter:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">arr</span>
</pre></div>
</div>
</div>
</div>
<p>For this algorithm we could only test 2 cases - when the list is already sorted, when the list is reversed.  But with distributions and the ability to generate <em>random</em> data, we can test <em>many</em> lists of numbers to confirm our algorithm is correct.</p>
<p>Here is a simple test that leverages randomness to test our sorting algorithm is correct:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">test_simple_sort_three</span><span class="p">():</span>
    <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">gauss</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)]</span>
    <span class="n">sorted_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:]</span>
    <span class="n">sorted_array</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">simple_sort</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">==</span> <span class="n">sorted_array</span>
    
<span class="n">test_simple_sort_three</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Notice that there was nothing <em>specific</em> about the input.  We are able to do this because we have a correct sorting algorithm handy.  Since multiple algorithms can do the same thing, if you have one correct reference implementation that’s all you need for testing purposes with random data.  There are many different correct sorting algorithms, each with their own running time, but all of them do the same thing.  That is, given an array of elements in some order, they will all return the array of elements in <em>sorted</em> order.</p>
<p>Continuing with this theme, let’s look at our integer to binary code again:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">integer_to_binary</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;0&#39;</span>
    <span class="n">biggest_power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">biggest_power_of_two</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">):</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">biggest_power_of_two</span><span class="p">)</span>
    <span class="n">binary_representation</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">upper_bound</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">power_of_two</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power_of_two</span> <span class="o">&gt;</span> <span class="n">number</span><span class="p">:</span>
            <span class="n">binary_representation</span> <span class="o">+=</span> <span class="s2">&quot;0&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binary_representation</span> <span class="o">+=</span> <span class="s2">&quot;1&quot;</span>
            <span class="n">number</span> <span class="o">-=</span> <span class="n">power_of_two</span>
    <span class="k">return</span> <span class="n">binary_representation</span>
</pre></div>
</div>
</div>
</div>
<p>Now instead of testing interatively on a large set of numbers to verify some level of correctness, we will test on a much smaller set:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">strip_leading</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">test_integer_to_binary</span><span class="p">():</span>
    <span class="n">tested_numbers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">random_number</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50000000</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">random_number</span> <span class="ow">in</span> <span class="n">tested_numbers</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">python_version</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">random_number</span><span class="p">)</span>
        <span class="n">python_version</span> <span class="o">=</span> <span class="n">strip_leading</span><span class="p">(</span><span class="n">python_version</span><span class="p">)</span>
        <span class="n">our_version</span> <span class="o">=</span> <span class="n">integer_to_binary</span><span class="p">(</span><span class="n">random_number</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">our_version</span> <span class="o">==</span> <span class="n">python_version</span>
        <span class="n">tested_numbers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random_number</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tested_numbers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">50</span><span class="p">:</span>
            <span class="k">break</span>

<span class="n">test_integer_to_binary</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>By introducing a random number we were able to sample from a <em>much</em> larger space of numbers.  But we only checked 50 cases instead of 5000.  This improves the confidence in our algorithm since we are drawing from a much larger set of choices.  As a consequence, we can test far fewer cases and be confident.</p>
<p>Asides:</p>
<ul class="simple">
<li><p>talk about psuedo number generators from veritasium</p></li>
<li><p>talk about power law versus logarithm, do algorithms actually follow logs or can we show experimentally that a power law is more appropriate?</p></li>
</ul>
<p>(do this after the final)</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./01/3"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="../2/Introduction_To_Proofs.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Introduction To Proofs</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="../4/Types_and_Induction.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Types</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By The Jupyter Book community<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>